/* Author: Harshvardhan Agrawal

#ifndef _MATRIXMUL_KERNEL_H_
#define _MATRIXMUL_KERNEL_H_

#include <stdio.h>

// This function uses a compare and swap technque to acquire a mutex/lock
__device__ void lock(int *mutex) {
	while(atomicCAS(mutex,0,1) != 0);
}

// This function uses an atomic exchange operation to release mutex/lock
__device__ void unlock(int *mutex){
	atomicExch(mutex,0);
}

// Declare 2D textures to hold grid1 and grid2 elements
texture<float, 1> grid1_on_tex;
texture<float, 1> grid2_on_tex;

__global__ void 
solver_kernel_naive(float* d_grid1, float* d_grid2, int size,float* d_diff,int *mutex){
	

	__shared__ float diff_per_thread[TILE_SIZE*TILE_SIZE];
	// Thread index
	int threadX = threadIdx.x;
	int threadY = threadIdx.y;

	// Block index
	int blockX = blockIdx.x;
	int blockY = blockIdx.y;

	// Find position in Matrix
	int column_number = blockDim.x * blockX + threadX;
	int row_number = blockDim.y * blockY + threadY;
	unsigned int threadId = threadY*TILE_SIZE + threadX;

	if (threadId>(size-1)) return;
//	if(row_number>=(size-1) || row_number==0 || column_number==0 || column_number>=(size-1)) return;

	if(row_number>0 && row_number<(size-1) && column_number>0 && column_number<(size-1)) {
		d_grid2[row_number*size + column_number] =\
							0.20*(d_grid1[row_number*size + column_number] +\
							d_grid1[(row_number-1)*size + column_number] +\
							d_grid1[(row_number+1)*size + column_number] +\
		        				d_grid1[row_number*size + (column_number-1)] +\
		                                        d_grid1[row_number*size + (column_number+1)]);
//   		 	diff_per_thread[threadY*TILE_SIZE + threadX] = fabsf(d_grid1[row_number*size + column_number] - d_grid2[row_number*size + column_number]);
		
		__syncthreads();
   		 	diff_per_thread[threadY*TILE_SIZE + threadX] = fabsf(d_grid1[row_number*size + column_number] - d_grid2[row_number*size + column_number]);
	
		d_grid1[row_number*size + column_number] = d_grid2[row_number*size + column_number];
		
		
		unsigned int i = (TILE_SIZE*TILE_SIZE)/2;

		// Reduce values generated by thread block to a single value. We assume that the number of threads per block is power of two.

		while(i!=0) {
			if(threadId < i) {
				diff_per_thread[threadId] += diff_per_thread[threadId + i];
			}
			__syncthreads();
			i /= 2;
		}
		// Accumalate the sum computed by this thread block into the global shared variable
		if(threadId == 0 ) {
			lock(mutex);
			*d_diff += diff_per_thread[0];
			unlock(mutex);
		}	
	}
}


__global__ void 
solver_kernel_optimized(float* d_grid1, float* d_grid2, int size,float* d_diff,int *mutex){
	
	__shared__ float diff_per_thread_texture[TILE_SIZE*TILE_SIZE];
	// Thread index
	int threadX = threadIdx.x;
	int threadY = threadIdx.y;

	// Block index
	int blockX = blockIdx.x;
	int blockY = blockIdx.y;

	//Find position in matrix
	int column_number = blockDim.x * blockX + threadX;
	int row_number = blockDim.y * blockY + threadY;
	unsigned int threadId = threadY*TILE_SIZE + threadX;
	
	if(threadId>(size-1)) return;
//	if(row_number>=(size-1) || row_number==0 || column_number==0 || column_number>=(size-1)) return;
	
	if(row_number>0 && row_number<(size-1) && column_number>0 && column_number<(size-1)) {
		d_grid2[row_number*size + column_number] =\
							0.20*(tex1Dfetch(grid1_on_tex,row_number*GRID_DIMENSION+column_number) +\
							tex1Dfetch(grid1_on_tex,column_number-1 + row_number*GRID_DIMENSION) +\
							tex1Dfetch(grid1_on_tex,column_number+1 + row_number*GRID_DIMENSION) +\
		        				tex1Dfetch(grid1_on_tex,column_number + (row_number-1)*GRID_DIMENSION) +\
		                                        tex1Dfetch(grid1_on_tex,column_number + (row_number+1)*GRID_DIMENSION));
 
/*		float temp1 = tex2D(grid1_on_tex_2D,column_number,row_number);
		float temp2 = tex2D(grid2_on_tex_2D,column_number,row_number);
		printf("diff1: %f diff_original:%f\n",fabsf(temp1-temp2),fabsf(d_grid1[row_number*size + column_number] - d_grid2[row_number*size + column_number]));
*/	 
//		diff_per_thread_texture[threadY*TILE_SIZE + threadX] = fabsf(d_grid1[row_number*size + column_number] - d_grid2[row_number*size + column_number]);
	
//		diff_per_thread_texture[threadId] = fabsf(temp1 - temp2);
		
		__syncthreads();
		diff_per_thread_texture[threadId] = fabsf(tex1Dfetch(grid1_on_tex,row_number*GRID_DIMENSION + column_number) - tex1Dfetch(grid2_on_tex,row_number*GRID_DIMENSION + column_number));
		d_grid1[row_number*size + column_number] = tex1Dfetch(grid2_on_tex,column_number + row_number*GRID_DIMENSION);
		
		
		unsigned int i = (TILE_SIZE*TILE_SIZE)/2;

		// Reduce values generated by thread block to a single value. We assume that the number of threads per block is power of two.

		while(i!=0) {
			if(threadId < i) {
				diff_per_thread_texture[threadId] += diff_per_thread_texture[threadId + i];
			}
			__syncthreads();
			i /= 2;
		}
		// Accumalate the sum computed by this thread block into the global shared variable
		if(threadId == 0 ) {
			lock(mutex);
			*d_diff += diff_per_thread_texture[0];
			unlock(mutex);
		}	
	}
}


#endif /* _MATRIXMUL_KERNEL_H_ */
